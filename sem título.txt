local IceHub = loadstring(game:HttpGet("https://raw.githubusercontent.com/hatak1212/old-backup/main/Ui.lib.txt"))()
local MainUI = IceHub.CreateMain()
local Tab_Kill = MainUI:NewTab("Main")
local Kill = Tab_Kill:NewSection("Main")
local Tab_Misc = MainUI:NewTab("Audio")
local Misc = Tab_Misc:NewSection("Audio")
local Tab_Avatar = MainUI:NewTab("Avatar")
local Avatar = Tab_Avatar:NewSection("Avatar")
local Tab_Map = MainUI:NewTab("All")
local Map = Tab_Map:NewSection("All")

Kill:NewLabel("Kill and View")

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local CurrentCamera = workspace.CurrentCamera

local viewEnabled = false
local currentTarget = nil
local characterAddedConn = nil
local lastValidTarget = nil

local notificationIconId = "rbxassetid://85219327131493"

-- Notificação com headshot
function notify(title, text, player)
    local icon = notificationIconId

    if player and Players:FindFirstChild(player.Name) then
        local success, thumb = pcall(function()
            return Players:GetUserThumbnailAsync(
                player.UserId,
                Enum.ThumbnailType.HeadShot,
                Enum.ThumbnailSize.Size150x150
            )
        end)
        if success and thumb then
            icon = thumb
        end
    end

    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Icon = icon,
        Duration = 4
    })
end

-- Buscar jogador
function findPlayerByName(partialName)
    if not partialName or partialName == "" then return nil end

    partialName = partialName:lower()
    local foundPlayers = {}

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local nameMatch = player.Name:lower():find(partialName, 1, true)
            local displayNameMatch = player.DisplayName:lower():find(partialName, 1, true)

            if nameMatch or displayNameMatch then
                table.insert(foundPlayers, {
                    player = player,
                    priority = (player.Name:lower():sub(1, #partialName) == partialName or player.DisplayName:lower():sub(1, #partialName) == partialName) and 1 or 2
                })
            end
        end
    end

    table.sort(foundPlayers, function(a, b)
        if a.priority ~= b.priority then
            return a.priority < b.priority
        end
        return #a.player.Name < #b.player.Name
    end)

    return foundPlayers[1] and foundPlayers[1].player or nil
end

-- Resetar câmera
function resetCamera()
    if LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() then
        CurrentCamera.CameraSubject = LocalPlayer.Character:WaitForChild("Humanoid")
    end
end

-- Definir alvo
function setViewTarget(targetPlayer)
    if not targetPlayer or not targetPlayer:IsDescendantOf(Players) then
        notify("Erro", "Jogador inválido ou desconectado.")
        stopViewing()
        return
    end

    currentTarget = targetPlayer
    getgenv().Target = targetPlayer.Name
    lastValidTarget = targetPlayer.Name

    if characterAddedConn then
        characterAddedConn:Disconnect()
    end

    characterAddedConn = targetPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        if viewEnabled and currentTarget == targetPlayer then
            local humanoid = char:WaitForChild("Humanoid", 5)
            if humanoid then
                CurrentCamera.CameraSubject = humanoid
            end
        end
    end)

    if targetPlayer.Character then
        local humanoid = targetPlayer.Character:FindFirstChild("Humanoid") or targetPlayer.Character:WaitForChild("Humanoid", 2)
        if humanoid then
            CurrentCamera.CameraSubject = humanoid
        end
    end
end

-- Parar visualização
function stopViewing()
    viewEnabled = false
    currentTarget = nil
    if characterAddedConn then
        characterAddedConn:Disconnect()
        characterAddedConn = nil
    end
    resetCamera()
    notify("View", "Visualização desativada.")
end

-- Render loop
RunService.RenderStepped:Connect(function()
    if viewEnabled and currentTarget then
        if not currentTarget:IsDescendantOf(game) then
            stopViewing()
            return
        end
        if currentTarget.Character then
            local humanoid = currentTarget.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and CurrentCamera.CameraSubject ~= humanoid then
                pcall(function()
                    CurrentCamera.CameraSubject = humanoid
                end)
            end
        end
    end
end)

-- UI Elements
local PlayerTextBox = Kill:NewTextBox("Target Player", "name or nickname..", function(texto)
    if texto == "" then
        if lastValidTarget then
            texto = lastValidTarget
        else
            notify("Erro", "Você precisa digitar um nome.")
            return
        end
    end

    local targetPlayer = findPlayerByName(texto)

    if targetPlayer and targetPlayer:IsDescendantOf(Players) then
        getgenv().Target = targetPlayer.Name
        lastValidTarget = targetPlayer.Name
        currentTarget = targetPlayer

        notify("Jogador Selecionado", "Alvo: " .. targetPlayer.DisplayName .. " (" .. targetPlayer.Name .. ")", targetPlayer)

        if viewEnabled then
            setViewTarget(targetPlayer)
        end
    else
        getgenv().Target = nil
        lastValidTarget = nil
        currentTarget = nil
        stopViewing()
        notify("Erro", "Nenhum jogador encontrado com: " .. texto)
    end
end)

Kill:NewToggle("View", function(state)
    viewEnabled = state
    if state and getgenv().Target then
        local targetPlayer = findPlayerByName(getgenv().Target)
        if targetPlayer and targetPlayer:IsDescendantOf(Players) then
            setViewTarget(targetPlayer)
            notify("View Ativado", "Observando " .. targetPlayer.DisplayName .. " (" .. targetPlayer.Name .. ")", targetPlayer)
        else
            notify("Erro", "Jogador não encontrado: " .. tostring(getgenv().Target))
            viewEnabled = false
        end
    else
        stopViewing()
    end
end)

Kill:NewButton("Goto", function()
    local success, err = pcall(function()
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")

        if not hrp then 
            notify("Goto", "Seu personagem não tem HumanoidRootPart.")
            return 
        end

        local targetName = getgenv().Target
        if not targetName then
            notify("Goto", "Nenhum jogador selecionado.")
            return
        end

        local targetPlayer = findPlayerByName(targetName)
        if not targetPlayer or not targetPlayer.Character then
            notify("Goto", "Jogador inválido ou offline.")
            return
        end

        local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then
            notify("Goto", "Jogador sem HumanoidRootPart.")
            return
        end

        hrp.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)
        notify("Teleportado", "Você foi até " .. targetPlayer.DisplayName .. " (" .. targetPlayer.Name .. ")", targetPlayer)
    end)

    if not success then
        warn("[GOTO] Erro ao teleportar:", err)
        notify("Erro", "Falha ao teleportar: " .. tostring(err))
    end
end)

-- Alvo inicial
if getgenv().Target then
    local targetPlayer = findPlayerByName(getgenv().Target)
    if targetPlayer and targetPlayer:IsDescendantOf(Players) then
        lastValidTarget = targetPlayer.Name
    else
        getgenv().Target = nil
    end
end

Kill:NewLabel("Canoe")

Kill:NewButton("Jail Canoe", function()
    local nome = getgenv().Target
    if not nome then
        warn("Nenhum jogador definido.")
        return
    end

    local AlvoSelecionado = game.Players:FindFirstChild(nome)
    if not AlvoSelecionado then
        warn("Jogador não encontrado.")
        return
    end

    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")

    if humanoid.Sit then
        humanoid.Sit = false
        task.wait(0.5)
    end

    root.CFrame = workspace.WorkspaceCom["001_CanoeCloneButton"].Button.CFrame
    task.wait(0.4)
    fireclickdetector(workspace.WorkspaceCom["001_CanoeCloneButton"].Button.ClickDetector, 0)
    task.wait(0.4)

    local canoe = workspace.WorkspaceCom["001_CanoeStorage"].Canoe
    local seat = canoe:FindFirstChild("VehicleSeat")
    if not canoe.PrimaryPart then
        canoe.PrimaryPart = seat
    end

    local tentativas = 0
    repeat
        char:MoveTo(seat.Position + Vector3.new(0, 3, 0))
        task.wait(0.05)
        seat:Sit(humanoid)
        tentativas += 1
    until humanoid.Sit == true or tentativas > 100

    if not humanoid.Sit then
        warn("Falhou em sentar no barco.")
        return
    end

    local alvoChar = AlvoSelecionado.Character or AlvoSelecionado.CharacterAdded:Wait()
    local alvoRoot = alvoChar:WaitForChild("HumanoidRootPart")
    local alvoHum = alvoChar:WaitForChild("Humanoid")

    local distancia = 10
    local sentido = 1
    local ativo = true

    while ativo and humanoid.Sit and alvoChar and alvoHum and alvoHum.Health > 0 do
        if alvoHum.SeatPart then
            -- Leva pro void
            local cfVoid = CFrame.new(Vector3.new(0, -12000, 0))
            for i = 1, 30 do
                canoe:SetPrimaryPartCFrame(cfVoid)
                char:SetPrimaryPartCFrame(cfVoid)
                alvoChar:SetPrimaryPartCFrame(cfVoid)
                task.wait()
            end

            if seat then
                seat.Throttle = 0
                seat.Steer = 0
            end
            if canoe:FindFirstChild("BodyVelocity") then
                canoe.BodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
            if canoe:FindFirstChild("BodyAngularVelocity") then
                canoe.BodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
            end

            game.StarterGui:SetCore("SendNotification", {
                Title = "ShnmaxHub",
                Text = AlvoSelecionado.Name .. " foi preso no void.",
                Duration = 5
            })

            -- Você volta e deixa o resto lá
            if root.Position.Y < -1000 then
                humanoid.Sit = false
                task.wait(0.2)
                root.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
            end

            ativo = false
        else
            local offset = alvoRoot.CFrame.LookVector * distancia * sentido
            local pos = alvoRoot.Position + offset
            canoe:SetPrimaryPartCFrame(CFrame.new(pos, alvoRoot.Position))
            sentido = -sentido
            task.wait()
        end
    end
end)

Kill:NewButton("Kill Canoe", function()
    local nome = getgenv().Target
    if not nome then
        warn("Nenhum jogador definido.")
        return
    end

    local AlvoSelecionado = game.Players:FindFirstChild(nome)
    if not AlvoSelecionado then
        warn("Jogador não encontrado.")
        return
    end

    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")

    -- Se estiver sentado, levanta
    if humanoid.Sit then
        humanoid.Sit = false
        task.wait(0.5)
    end

    -- Vai até o botão do barco
    root.CFrame = workspace.WorkspaceCom["001_CanoeCloneButton"].Button.CFrame
    task.wait(0.4)
    fireclickdetector(workspace.WorkspaceCom["001_CanoeCloneButton"].Button.ClickDetector, 0)
    task.wait(0.4)

    local canoe = workspace.WorkspaceCom["001_CanoeStorage"].Canoe
    local seat = canoe:FindFirstChild("VehicleSeat")

    if not canoe.PrimaryPart then
        canoe.PrimaryPart = seat
    end

    -- Tenta sentar
    local tentativas = 0
    repeat
        char:MoveTo(seat.Position + Vector3.new(0, 3, 0))
        task.wait(0.05)
        seat:Sit(humanoid)
        tentativas += 1
    until humanoid.Sit == true or tentativas > 100

    if not humanoid.Sit then
        warn("Falhou em sentar no barco.")
        return
    end

    local alvoChar = AlvoSelecionado.Character or AlvoSelecionado.CharacterAdded:Wait()
    local alvoRoot = alvoChar:WaitForChild("HumanoidRootPart")
    local alvoHum = alvoChar:WaitForChild("Humanoid")

    local distancia = 10
    local sentido = 1
    local ativo = true

    while ativo and humanoid.Sit and alvoChar and alvoHum and alvoHum.Health > 0 do
        if alvoHum.SeatPart then
            -- VOID
            local cfVoid = CFrame.new(Vector3.new(0, -12000, 0))
            for i = 1, 30 do
                canoe:SetPrimaryPartCFrame(cfVoid)
                char:SetPrimaryPartCFrame(cfVoid)
                alvoChar:SetPrimaryPartCFrame(cfVoid)
                task.wait()
            end

            if seat then
                seat.Throttle = 0
                seat.Steer = 0
            end
            if canoe:FindFirstChild("BodyVelocity") then
                canoe.BodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
            if canoe:FindFirstChild("BodyAngularVelocity") then
                canoe.BodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
            end

            game.StarterGui:SetCore("SendNotification", {
                Title = "ShnmaxHub",
                Text = AlvoSelecionado.Name .. " está no void!",
                Duration = 5
            })

            -- Se estiver em zona de teleporte, levanta, teleporta e destrói o barco
            if root.Position.Y < -1000 then
                humanoid.Sit = false
                task.wait(0.2)
                root.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                task.wait(0.2)

                -- Tenta destruir o barco
                pcall(function()
                    if canoe and canoe.Parent then
                        canoe:Destroy()
                    end
                end)
            end

            ativo = false
        else
            local offset = alvoRoot.CFrame.LookVector * distancia * sentido
            local pos = alvoRoot.Position + offset
            canoe:SetPrimaryPartCFrame(CFrame.new(pos, alvoRoot.Position))
            sentido = -sentido
            task.wait()
        end
    end
end)

Kill:NewButton("Fling Canoe", function()
    local nome = getgenv().Target
    if not nome then
        warn("Nenhum jogador definido.")
        return
    end

    local AlvoSelecionado = game.Players:FindFirstChild(nome)
    if not AlvoSelecionado then
        warn("Jogador não encontrado.")
        return
    end

    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")

    if humanoid.Sit then
        humanoid.Sit = false
        task.wait(0.5)
    end

    root.CFrame = workspace.WorkspaceCom["001_CanoeCloneButton"].Button.CFrame
    task.wait(0.4)
    fireclickdetector(workspace.WorkspaceCom["001_CanoeCloneButton"].Button.ClickDetector, 0)
    task.wait(0.4)

    local canoe = workspace.WorkspaceCom["001_CanoeStorage"].Canoe
    local seat = canoe:FindFirstChild("VehicleSeat")

    if not canoe.PrimaryPart then
        canoe.PrimaryPart = seat
    end

    -- Sentar no barco
    local tentativas = 0
    repeat
        char:MoveTo(seat.Position + Vector3.new(0, 3, 0))
        task.wait(0.05)
        seat:Sit(humanoid)
        tentativas += 1
    until humanoid.Sit == true or tentativas > 100

    if not humanoid.Sit then
        warn("Falhou em sentar no barco.")
        return
    end

    -- Prepara peças do alvo
    local alvoChar = AlvoSelecionado.Character or AlvoSelecionado.CharacterAdded:Wait()
    local alvoRoot = alvoChar:WaitForChild("HumanoidRootPart")
    local alvoHum = alvoChar:WaitForChild("Humanoid")

    -- Fling mode
    local force = Instance.new("BodyForce", canoe.PrimaryPart)
    local angular = Instance.new("BodyAngularVelocity", canoe.PrimaryPart)
    angular.MaxTorque = Vector3.new(1e9, 1e9, 1e9)
    angular.AngularVelocity = Vector3.new(1000, 5000, 1000) -- rotação em torno do Y
    angular.P = 1e9

    local ativo = true
    local distancia = 10
    local sentido = 1

    while ativo and humanoid.Sit and alvoChar and alvoHum and alvoHum.Health > 0 do
        -- Direção até o alvo
        local offset = alvoRoot.CFrame.LookVector * distancia * sentido
        local pos = alvoRoot.Position + offset
        canoe:SetPrimaryPartCFrame(CFrame.new(pos, alvoRoot.Position))
        sentido = -sentido

        -- Força extrema aplicada ao barco (direto pro centro do alvo)
        local dir = (alvoRoot.Position - canoe.PrimaryPart.Position).Unit
        force.Force = dir * 1e6 + Vector3.new(0, workspace.Gravity * canoe.PrimaryPart:GetMass(), 0)

        task.wait()
    end

    -- Cleanup
    angular:Destroy()
    force:Destroy()
end)

Kill:NewButton("Disable - FlingCanoe", function()
    getgenv().FlingAtivo = false

    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not root then return end

    -- Levanta se estiver sentado
    if humanoid.Sit then
        humanoid.Sit = false
        task.wait(0.3)
    end

    -- Tenta destruir o barco
    local canoe = workspace:FindFirstChild("WorkspaceCom")
    if canoe then
        local canoeStorage = canoe:FindFirstChild("001_CanoeStorage")
        if canoeStorage and canoeStorage:FindFirstChild("Canoe") then
            pcall(function()
                canoeStorage.Canoe:Destroy()
            end)
        end
    end

    -- Volta pra posição original
    local retorno = getgenv().RetornoPos or Vector3.new(1118.81, 75.998, -1138.61)
    root.CFrame = CFrame.new(retorno)

    -- Função pra limpar BodyVelocity e Attachments do alvo
    local function clearTargetForces()
        local target = game.Players:FindFirstChild(getgenv().Target)
        if target and target.Character then
            for _, obj in ipairs(target.Character:GetDescendants()) do
                if obj:IsA("BodyVelocity") or obj:IsA("Attachment") then
                    obj:Destroy()
                end
            end
        end
    end

    -- Reset físico seguro
    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    root.Anchored = true
    root.CFrame = CFrame.new(retorno)
    root.AssemblyLinearVelocity = Vector3.zero
    root.AssemblyAngularVelocity = Vector3.zero

    print("Jogador teleportado para a posição segura.")
    clearTargetForces()

    task.wait(2)

    root.Anchored = false
    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    print("Jogador liberado com segurança.")
end)
Kill:NewLabel("Ball")

Kill:NewButton("Fling Ball", function()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local player = Players.LocalPlayer
    local targetPlayer = Players:FindFirstChild(getgenv().Target)
    if not targetPlayer or not targetPlayer.Character then
        warn("Nenhum jogador selecionado.")
        return
    end

    -- Limpa as forças antigas da bola
    local function clearForces(ball)
        for _, obj in ipairs(ball:GetChildren()) do
            if obj:IsA("BodyForce") or obj:IsA("BodyVelocity") or obj:IsA("BodyPosition") or obj:IsA("BodyAngularVelocity") then
                obj:Destroy()
            end
        end
    end

    -- Aplica forças poderosas na bola
    local function applyFlingForces(ball)
        clearForces(ball)

        local force = Instance.new("BodyForce")
        force.Force = Vector3.new(1e14, 1e14, 1e14)
        force.Parent = ball

        local spin = Instance.new("BodyAngularVelocity")
        spin.AngularVelocity = Vector3.new(1e14, 1e14, 1e14)
        spin.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        spin.P = 1e14
        spin.Parent = ball
    end

    -- Espera até a bola estar no workspace
    local function waitForWorkspaceBall()
        local ballName = "Soccer" .. player.Name
        local ball
        repeat
            ball = workspace.WorkspaceCom["001_SoccerBalls"]:FindFirstChild(ballName)
            task.wait()
        until ball
        return ball
    end

    -- Limpa ferramentas antigas e pega a bola nova
    ReplicatedStorage.RE:FindFirstChild("1Clea1rTool1s"):FireServer("PlayerWantsToDeleteTool", "SoccerBall")
    ReplicatedStorage.RE:FindFirstChild("1Too1l"):InvokeServer("PickingTools", "SoccerBall")

    repeat task.wait() until player.Backpack:FindFirstChild("SoccerBall")
    local localBall = player.Backpack:FindFirstChild("SoccerBall")
    if not localBall then
        warn("Bola não encontrada na mochila.")
        return
    end

    localBall.Parent = player.Character
    task.wait(0.25) -- Aguarda a bola ser carregada na Character

    local workspaceBall = waitForWorkspaceBall()
    applyFlingForces(workspaceBall) -- garante forças logo que a bola está no workspace

    -- Tracking com bola 2 studs à frente quando o alvo andar
    local function trackAndFling()  
    local char = targetPlayer.Character  
    if not char then return end  

    local hrp = char:FindFirstChild("HumanoidRootPart")  
    local humanoid = char:FindFirstChildOfClass("Humanoid")  
    if not hrp or not humanoid then return end  

    local altToggle = true  
    RunService.Heartbeat:Connect(function()  
        if not workspaceBall or not hrp or humanoid.Health <= 0 then return end  

        local speed = hrp.Velocity.Magnitude  
        local direction = hrp.Velocity.Unit  

        -- Reaplica forças todo frame pra garantir consistência do fling  
        applyFlingForces(workspaceBall)  

        if speed > 1 then  
            local forwardPos = hrp.Position + direction * 6  
            workspaceBall.CFrame = CFrame.new(forwardPos + Vector3.new(0, -1, 0))  
        else  
            local offsetY = altToggle and 1 or -1  
            workspaceBall.CFrame = CFrame.new(hrp.Position + Vector3.new(0, offsetY, 0))  
            altToggle = not altToggle  
        end  
    end)  
end

    trackAndFling()
end)

Kill:NewButton("Press! Troll Error FilterChatMessage.Reconnecting..", function()
if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService then game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("hi\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\Frutiger Aero: Odeio coqquette Hub ☑️") else game:GetService("StarterGui"):SetCore("SendNotification", {Title = "Not Supported", Text = "This game has the legacy ROBLOX chat version. The script can only be used in the new version of the ROBLOX chat. Sorry :("}) end
end)

Kill:NewLabel("Couch")

Kill:NewButton("Bring Couch", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Backpack = Player:WaitForChild("Backpack")
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")
    local RootPart = Character:WaitForChild("HumanoidRootPart")

    -- Função para checar se já tem o Couch (equipado ou na backpack)
    local function HasCouch()
        return Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
    end

    -- Equipar Couch, ajustar GripPos e só então equipar para usar
    local function EquipCouch()
        if HasCouch() then return true end

        local remote = ReplicatedStorage:FindFirstChild("RE") and ReplicatedStorage.RE:FindFirstChild("1Too1l")
        if not remote then
            warn("Remote para equipar Couch não encontrado.")
            return false
        end

        local args = { "PickingTools", "Couch" }
        remote:InvokeServer(unpack(args))

        local timeout = 5
        local startTime = tick()
        while not Backpack:FindFirstChild("Couch") and tick() - startTime < timeout do
            task.wait(0.1)
        end

        local couchTool = Backpack:FindFirstChild("Couch")
        if not couchTool then
            warn("Falha ao obter Couch na backpack.")
            return false
        end

        -- Ajusta GripPos para reposicionar o item
        if couchTool:FindFirstChild("Handle") then
            couchTool.GripPos = Vector3.new(2, 5, -1)
        else
            warn("Handle não encontrado no item Couch")
        end

        -- Agora equipa o Couch ajustado
        Humanoid:EquipTool(couchTool)
        return true
    end

    -- Equipa o Couch e só segue se conseguir
    if not EquipCouch() then
        return
    end

    -- Seleciona o alvo
    local TargetPlayer = Players:FindFirstChild(getgenv().Target)
    if not TargetPlayer or not TargetPlayer.Character then
        return warn("Alvo inválido ou personagem não encontrado.")
    end

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    -- Salva posição original se o player estiver parado
    if RootPart.Velocity.Magnitude < 50 then
        getgenv().OldPos = RootPart.CFrame
    end

    -- Função que reposiciona o player em relação a uma base com offset e ângulo
    local function FPos(BasePart, Pos, Ang)
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
        RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end

    -- Movimento dinâmico para 'empurrar' o alvo
    local function SFBasePart(BasePart)
        local TimeToWait = 10
        local Time = tick()
        local Angle = 0

        repeat
            if RootPart and THumanoid then
                if BasePart.Velocity.Magnitude < 50 then
                    Angle += 500
                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                    task.wait()
                else
                    for _, offset in ipairs({1.5, -1.5, 1.5, 1.5, -1.5, 1.5, -1.5, -1.5, -1.5}) do
                        FPos(BasePart, CFrame.new(0, offset, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                    end
                end
            else
                break
            end
        until
            BasePart.Velocity.Magnitude > 500
            or BasePart.Parent ~= TCharacter
            or TargetPlayer.Parent ~= Players
            or not (TargetPlayer.Character == TCharacter)
            or THumanoid.Sit
            or Humanoid.Health <= 0
            or tick() > Time + TimeToWait
    end

    workspace.FallenPartsDestroyHeight = 0/0

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    if TRootPart and THead then
        if (TRootPart.Position - THead.Position).Magnitude > 5 then
            SFBasePart(THead)
        else
            SFBasePart(TRootPart)
        end
    elseif TRootPart then
        SFBasePart(TRootPart)
    elseif THead then
        SFBasePart(THead)
    elseif Handle then
        SFBasePart(Handle)
    else
        warn("Nenhuma parte válida do alvo encontrada.")
    end

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    workspace.CurrentCamera.CameraSubject = Humanoid

    repeat
        RootPart.CFrame = getgenv().OldPos * CFrame.new(0, 0.5, 0)
        Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, 0.5, 0))
        Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        for _, part in ipairs(Character:GetChildren()) do
            if part:IsA("BasePart") then
                part.Velocity = Vector3.new()
                part.RotVelocity = Vector3.new()
            end
        end
        task.wait()
    until (RootPart.Position - getgenv().OldPos.Position).Magnitude < 25

    workspace.FallenPartsDestroyHeight = getgenv().FPDH or -500

Task.wait(0.5)

local argsClear = {
        [1] = "PlayerWantsToDeleteTool",
        [2] = "Couch"
    }
    local remoteClear = ReplicatedStorage.RE:FindFirstChild("1Clea1rTool1s")
    if remoteClear then
        remoteClear:FireServer(unpack(argsClear))
    end
end)

Kill:NewToggle("Jail Couch", function(Value)
    getgenv().JailCouchAtivo = Value

    if not Value then return end

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")
    local RootPart = Character:WaitForChild("HumanoidRootPart")
    local Backpack = Player:WaitForChild("Backpack")

    -- Verificar e equipar o item "Couch"
    local function EquipCouch()
        local couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
        if not couchTool then
            local args = { [1] = "PickingTools", [2] = "Couch" }
            local remote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Too1l")
            if remote then
                remote:InvokeServer(unpack(args))
                local timeout = 5
                local waited = 0
                repeat
                    couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
                    task.wait(0.1)
                    waited += 0.1
                until couchTool or waited >= timeout
            end
        end

        if couchTool then
            if couchTool:FindFirstChild("Handle") then
                couchTool.GripPos = Vector3.new(2, 5, -1)
            end

            if Backpack:FindFirstChild("Couch") then
                Humanoid:EquipTool(couchTool)
            else
                couchTool.Parent = Backpack
                task.wait()
                Humanoid:EquipTool(couchTool)
            end
        end
    end

    EquipCouch()

    -- Seleção do alvo
    local TargetPlayer = Players:FindFirstChild(getgenv().Target)
    if not TargetPlayer or not TargetPlayer.Character then
        return warn("Alvo inválido ou personagem não encontrado.")
    end

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and (THumanoid.RootPart or TCharacter:FindFirstChild("HumanoidRootPart"))

    if RootPart and RootPart.Position.Magnitude < 99999 then
        getgenv().OldPos = RootPart.CFrame
    end

    local function FPos(BasePart, Pos, Ang)
        local targetCFrame = CFrame.new(BasePart.Position) * Pos * Ang
        RootPart.CFrame = targetCFrame
        Character:SetPrimaryPartCFrame(targetCFrame)
    end

    -- Dança forçando o alvo a sentar
    local function SFBasePart(BasePart)
        local TempoMax = 50
        local Inicio = tick()
        local Angulo = 0

        repeat
            if not THumanoid or not RootPart then break end
            if BasePart.Velocity.Magnitude < 50 then
                Angulo += 500
                FPos(BasePart, CFrame.new(0, 1.5, 0), CFrame.Angles(math.rad(Angulo), 0, 0)) task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(Angulo), 0, 0)) task.wait()
                FPos(BasePart, CFrame.new(2.25, 1.5, -2.25), CFrame.Angles(math.rad(Angulo), 0, 0)) task.wait()
                FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25), CFrame.Angles(math.rad(Angulo), 0, 0)) task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0)) task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0)) task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0)) task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, TRootPart.Velocity.Magnitude / -1.25), CFrame.Angles(0, 0, 0)) task.wait()
            end
        until tick() > Inicio + TempoMax or THumanoid.Sit or Humanoid.Health <= 0
    end

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    if TRootPart then
        SFBasePart(TRootPart)
    end
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

    -- Início do loop infinito de Jail
    task.spawn(function()
        while getgenv().JailCouchAtivo and Character and Character:FindFirstChild("HumanoidRootPart") do
            Character:SetPrimaryPartCFrame(CFrame.new(0, -450, 0))
            task.wait(0.15)
        end
    end)
end)

Kill:NewButton("Kill Couch", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")
    local RootPart = Character:WaitForChild("HumanoidRootPart")
    local Backpack = Player:WaitForChild("Backpack")

    -- Verificar e equipar o item "Couch"
    local function EquipCouch()
        local couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
        if not couchTool then
            local args = { [1] = "PickingTools", [2] = "Couch" }
            local remote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Too1l")
            if remote then
                remote:InvokeServer(unpack(args))
                local timeout = 5
                local waited = 0
                repeat
                    couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
                    task.wait(0.1)
                    waited += 0.1
                until couchTool or waited >= timeout
            end
        end

        if couchTool then
            -- Aplica o GripPos personalizado
            if couchTool:FindFirstChild("Handle") then
                couchTool.GripPos = Vector3.new(2, 5, -1)
            else
                warn("Handle não encontrado no item Couch")
            end

            -- Reequipar após mudar GripPos
            if Backpack:FindFirstChild("Couch") then
                Humanoid:EquipTool(couchTool)
            else
                couchTool.Parent = Backpack
                task.wait()
                Humanoid:EquipTool(couchTool)
            end
        else
            warn("Couch não encontrado após tentativa de pegar.")
        end
    end

    EquipCouch()

    -- Seleção do alvo
    local TargetPlayer = Players:FindFirstChild(getgenv().Target)
    if not TargetPlayer or not TargetPlayer.Character then
        return warn("Alvo inválido ou personagem não encontrado.")
    end

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and (THumanoid.RootPart or TCharacter:FindFirstChild("HumanoidRootPart"))

    -- Salva posição original
    if RootPart and RootPart.Position.Magnitude < 99999 then
        getgenv().OldPos = RootPart.CFrame
    end

    -- Posicionamento dinâmico
    local function FPos(BasePart, Pos, Ang)
        local targetCFrame = CFrame.new(BasePart.Position) * Pos * Ang
        RootPart.CFrame = targetCFrame
        Character:SetPrimaryPartCFrame(targetCFrame)
    end

    -- MONITORA se o alvo sentar
    task.spawn(function()
        local alreadyHandled = false
        while THumanoid and THumanoid.Parent and Humanoid.Health > 0 and not alreadyHandled do
            if THumanoid.Sit then
                alreadyHandled = true

                -- Vai pro void
                local escapePos = CFrame.new(0, -700, 0)
                RootPart.CFrame = escapePos
                Character:SetPrimaryPartCFrame(escapePos)

                -- Espera 1 segundo
                task.wait(1)

                -- Dispara o remote pra desequipar a Couch
                local clearRemote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Clea1rTool1s")
                if clearRemote then
                    clearRemote:FireServer("ClearAllTools")
                end

                task.wait(0.3)

                -- Só depois de remover a Couch, volta pra posição original
                if getgenv().OldPos then
                    RootPart.CFrame = getgenv().OldPos
                    Character:SetPrimaryPartCFrame(getgenv().OldPos)
                    Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
            task.wait(0.1)
        end
    end)

    -- Dança do push (força o alvo a sentar)
    local function SFBasePart(BasePart)
        local TempoMax = 5
        local Inicio = tick()
        local Angulo = 0

        repeat
            if not THumanoid or not RootPart then break end

            if BasePart.Velocity.Magnitude < 50 then
                Angulo += 500

                FPos(BasePart, CFrame.new(0, 1.5, 0), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(2.25, 1.5, -2.25), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25), CFrame.Angles(math.rad(Angulo), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, TRootPart.Velocity.Magnitude / -1.25), CFrame.Angles(0, 0, 0))
                task.wait()
            end
        until tick() > Inicio + TempoMax or THumanoid.Sit or Humanoid.Health <= 0
    end

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    if TRootPart then
        SFBasePart(TRootPart)
    else
        warn("Parte do corpo do alvo não encontrada para movimentação.")
    end

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)

local argsClear = {
        [1] = "PlayerWantsToDeleteTool",
        [2] = "Couch"
    }
    local remoteClear = ReplicatedStorage.RE:FindFirstChild("1Clea1rTool1s")
    if remoteClear then
        remoteClear:FireServer(unpack(argsClear))
    end
end)

Kill:NewButton("Fling Couch", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Player = Players.LocalPlayer
    local Backpack = Player:WaitForChild("Backpack")
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local Humanoid = Character:WaitForChild("Humanoid")

    local function HasCouch()
        return Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
    end

    local function EquipCouch()
        local couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
        if couchTool then
            Humanoid:EquipTool(couchTool)
            return couchTool
        end
        return nil
    end

    local function IsGripAdjusted(tool)
        if not tool or not tool:FindFirstChild("Handle") then return false end
        local grip = tool.GripPos
        return (grip - Vector3.new(2, 5, -1)).Magnitude < 0.01
    end

    local couchTool = nil

    if HasCouch() then
        couchTool = EquipCouch()
        if couchTool and not IsGripAdjusted(couchTool) then
            couchTool.GripPos = Vector3.new(2, 5, -1)
            Humanoid:UnequipTools()
            task.wait(0.1)
            Humanoid:EquipTool(couchTool)
            task.wait(0.5)
        end
    else
        local remote = ReplicatedStorage.RE:FindFirstChild("1Too1l")
        if not remote then
            warn("Remote 1Too1l não encontrado!")
            return
        end
        local args = {"PickingTools", "Couch"}
        local success, err = pcall(function()
            remote:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Erro ao invocar remote:", err)
            return
        end

        local timeout, waited = 5, 0
        repeat
            task.wait(0.1)
            waited += 0.1
        until HasCouch() or waited >= timeout

        if not HasCouch() then
            warn("Couch não apareceu após solicitação.")
            return
        end

        couchTool = EquipCouch()
        if couchTool then
            couchTool.GripPos = Vector3.new(2, 5, -1)
            Humanoid:UnequipTools()
            task.wait(0.1)
            Humanoid:EquipTool(couchTool)
            task.wait(0.5)
        else
            warn("Falha ao equipar Couch após pegar.")
            return
        end
    end

    local RootPart = Character:WaitForChild("HumanoidRootPart")
    local OldPos = RootPart.CFrame

    getgenv().AllowFling = true

    local TargetPlayer = Players:FindFirstChild(getgenv().Target)
    if not TargetPlayer or not TargetPlayer.Character then
        warn("Alvo inválido.")
        return
    end

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")
    local Seat = TCharacter:FindFirstChildWhichIsA("Seat", true)
    local BasePart = Seat or TRootPart or THead or Handle

    if not BasePart then
        warn("Nenhuma parte válida do alvo.")
        return
    end

    workspace.FallenPartsDestroyHeight = 0/0
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    local BV = Instance.new("BodyVelocity")
    BV.Name = "FlingForce"
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
    BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

    local function FPos(BasePart, Pos, Ang)
        if not getgenv().AllowFling then return end
        local cf = BasePart.CFrame * Pos * Ang
        RootPart.CFrame = cf
        Character:SetPrimaryPartCFrame(cf)
        RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end

    task.spawn(function()
        local Angle = 0
        while getgenv().AllowFling and TargetPlayer.Parent == Players and BasePart:IsDescendantOf(TCharacter) do
            Angle += 100
            local axisIndex = 1
local function randVal()
    local value = math.random(-150, 150) / 100
    local x, y, z = 0, 0, 0
    if axisIndex == 1 then
        x = value
    elseif axisIndex == 2 then
        y = value
    elseif axisIndex == 3 then
        z = value
    end
    axisIndex = (axisIndex % 3) + 1
    return x, y, z
end

local function randXZ()
    return math.random(-225, 225) / 100
end

local moves = {
    -- Mistura total entre X, Y e Z aleatórios
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),

    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),
    CFrame.new(randVal()),

    -- WalkSpeed (mantido)
    CFrame.new(randVal()) + Vector3.new(0, 0, THumanoid.WalkSpeed / 2),
    CFrame.new(randVal()) + Vector3.new(0, 0, -THumanoid.WalkSpeed / 2),
    CFrame.new(randVal()) + Vector3.new(0, 0, THumanoid.WalkSpeed),
    CFrame.new(randVal()) + Vector3.new(0, 0, -THumanoid.WalkSpeed),
    CFrame.new(randVal()) + Vector3.new(0, 0, THumanoid.WalkSpeed * 1.5),
    CFrame.new(randVal()) + Vector3.new(0, 0, -THumanoid.WalkSpeed * 1.5),

    -- Diagonais com 3 eixos randômicos
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),
    CFrame.new(randVal()) + Vector3.new(0, 0, randXZ()),

    -- Velocity (mantido)
    CFrame.new(randVal()) + Vector3.new(0, 0, TRootPart.Velocity.Magnitude / 2),
    CFrame.new(randVal()) + Vector3.new(0, 0, -TRootPart.Velocity.Magnitude / 2),
    CFrame.new(randVal()) + Vector3.new(0, 0, TRootPart.Velocity.Magnitude / 1.25),
    CFrame.new(randVal()) + Vector3.new(0, 0, -TRootPart.Velocity.Magnitude / 1.25),
    CFrame.new(randVal()) + Vector3.new(0, 0, TRootPart.Velocity.Magnitude),
    CFrame.new(randVal()) + Vector3.new(0, 0, -TRootPart.Velocity.Magnitude),

    -- MoveDirection (mantido)
    CFrame.new(THumanoid.MoveDirection * 2.25) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * 1.5) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * 1.125) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * -2.25) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * -1.5) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * -1.125) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * 1.5) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * 1.125) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * -1.5) + Vector3.new(randVal()),
    CFrame.new(THumanoid.MoveDirection * -1.125) + Vector3.new(randVal()),
}

            for _, move in ipairs(moves) do
                if not getgenv().AllowFling then break end
                FPos(BasePart, move + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                task.wait()
            end
        end

        -- Quando alvo senta ou sai do jogo
        repeat task.wait(0.1)
        until not TargetPlayer or TargetPlayer.Parent ~= Players or THumanoid.Sit

        -- Desativa o fling
        getgenv().AllowFling = false
        task.wait(0.25)

        -- Volta para posição original
        RootPart.CFrame = OldPos
        Character:SetPrimaryPartCFrame(OldPos)

        -- Remove Couch via Remote
        local argsClear = {
            [1] = "PlayerWantsToDeleteTool",
            [2] = "Couch"
        }
        local remoteClear = ReplicatedStorage.RE:FindFirstChild("1Clea1rTool1s")
        if remoteClear then
            remoteClear:FireServer(unpack(argsClear))
            print("Couch foi removido via remote!")
        else
            warn("Remote 1Clea1rTool1s não encontrado!")
        end
    end)
end)

Kill:NewButton("Disable - Fling Couch", function()
    -- Desativa flags globais
    getgenv().AllowFling = false
    getgenv().AllowReturn = false

    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")

    if not RootPart or not Humanoid then
        warn("RootPart ou Humanoid não encontrado.")
        return
    end

    local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)

    -- Destrói qualquer tipo de força ou constraint
    for _, obj in ipairs(Character:GetDescendants()) do
        if obj:IsA("BodyMover") or obj:IsA("Constraint") or obj:IsA("VectorForce") or obj:IsA("AlignPosition") or obj:IsA("AlignOrientation") or obj:IsA("LinearVelocity") or obj:IsA("Torque") then
            pcall(function()
                obj:Destroy()
            end)
        end
    end

    -- Paralisa o jogador com estilo
    Humanoid.PlatformStand = true
    RootPart.Anchored = true
    RootPart.AssemblyLinearVelocity = Vector3.zero
    RootPart.AssemblyAngularVelocity = Vector3.zero

    -- Teleporta para local seguro
    RootPart.CFrame = CFrame.new(fixedReturnPos)
    print("Jogador teleportado para a posição segura.")

    -- Espera antes de liberar
    task.wait(3)

    -- Libera o jogador
    RootPart.Anchored = false
    Humanoid.PlatformStand = false
    print("Jogador liberado com segurança.")
end)

Kill:NewLabel("Vehicle")

Kill:NewButton("Active - FlingBus", function()
	local Player = game.Players.LocalPlayer
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
	local Vehicles = workspace:FindFirstChild("Vehicles")
	local OldPos = RootPart and RootPart.CFrame

	if not Humanoid or not RootPart then return end

	local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
	if not PCar then
		RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
		task.wait(0.5)
		local Remote = game.ReplicatedStorage:FindFirstChild("RE") and game.ReplicatedStorage.RE:FindFirstChild("1Ca1r")
		if Remote then Remote:FireServer("PickingCar", "Bus") end
		task.wait(0.5)
		PCar = Vehicles:FindFirstChild(Player.Name.."Car")
	end

	local timeout = 5
	while timeout > 0 and not PCar do
		task.wait(0.25)
		PCar = Vehicles:FindFirstChild(Player.Name.."Car")
		timeout -= 0.25
	end
	if not PCar then return end

	task.wait(0.5)
	if PCar and not Humanoid.Sit then
		local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
		if Seat then
			repeat task.wait()
				RootPart.CFrame = Seat.CFrame
			until Humanoid.Sit
		end
	end

	local attachment, force

	local function getTargetInfo()
		while true do
			local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
			if TargetPlayer then
				local TargetC = TargetPlayer.Character
				local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
				local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")
				if TargetC and TargetH and TargetRP then
					return TargetC, TargetH, TargetRP
				end
			end
			task.wait(0.2)
		end
	end

	local TargetC, TargetH, TargetRP = getTargetInfo()

	-- Ativando bodyvelocity no alvo
	attachment = Instance.new("Attachment", TargetRP)
	force = Instance.new("BodyVelocity")
	force.Velocity = Vector3.new(0, 999999999, 0)
	force.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	force.P = 500
	force.Parent = attachment

	-- Ativando força no carro
	for _, part in ipairs(PCar:GetDescendants()) do
		if part:IsA("BasePart") then
			local bv = Instance.new("BodyVelocity")
			bv.Velocity = Vector3.new(0, 99999999, 0)
			bv.MaxForce = Vector3.new(0, math.huge, 0)
			bv.P = 500
			bv.Parent = part
		end
	end

	local Angles = 0
	local YRotation = 0

	while PCar.Parent do
		task.wait()
		Angles += 100
		YRotation += 5000
		local Rotation = CFrame.Angles(math.rad(Angles), math.rad(YRotation + 180), 0)

		-- Reconfirma alvo
		if not (TargetC and TargetH and TargetRP and TargetRP.Parent) then
			TargetC, TargetH, TargetRP = getTargetInfo()
			if attachment then attachment:Destroy() end
			if force then force:Destroy() end
			attachment = Instance.new("Attachment", TargetRP)
			force = Instance.new("BodyVelocity")
			force.Velocity = Vector3.new(0, 99999999, 0)
			force.MaxForce = Vector3.new(0, math.huge, 0)
			force.P = 500
			force.Parent = attachment
		end

		local function flingAttack(offset)
			local newPos = TargetRP.Position + offset + (TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.1)
			local newCF = CFrame.new(newPos) * Rotation
			PCar:SetPrimaryPartCFrame(newCF)
		end

		flingAttack(Vector3.new(0, 1, 0))
		flingAttack(Vector3.new(0, -2.25, 5))
		flingAttack(Vector3.new(0, 2.25, 0.25))
		flingAttack(Vector3.new(-2.25, -1.5, 2.25))
		flingAttack(Vector3.new(0, 1.5, 0))
		flingAttack(Vector3.new(0, -1.5, 0))
	end

	if attachment then attachment:Destroy() end
	if force then force:Destroy() end
	Humanoid.Sit = false
	task.wait(0.1)
	if OldPos then RootPart.CFrame = OldPos end
end)
   
Kill:NewButton("Disable - FlingBus", function()
    local remote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r")
    if remote then
        remote:FireServer("DeleteAllVehicles")
    end

    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")

    if not RootPart or not Humanoid then
        warn("RootPart ou Humanoid não encontrado.")
        return
    end

    local function clearTargetForces()
        local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
        if TargetPlayer and TargetPlayer.Character then
            for _, obj in ipairs(TargetPlayer.Character:GetDescendants()) do
                if obj:IsA("BodyVelocity") or obj:IsA("Attachment") then
                    obj:Destroy()
                end
            end
        end
    end

    local Vehicles = workspace:FindFirstChild("Vehicles")
    if Vehicles then
        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if PCar then
            for _, part in ipairs(PCar:GetDescendants()) do
                if part:IsA("BodyVelocity") or part:IsA("Attachment") then
                    part:Destroy()
                end
            end
        end
    end

    -- Reset do personagem com segurança
    local fixedReturnPos = Vector3.new(1118.81, 75.998, -1138.61)

    Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
    RootPart.Anchored = true
    RootPart.CFrame = CFrame.new(fixedReturnPos)
    RootPart.AssemblyLinearVelocity = Vector3.zero
    RootPart.AssemblyAngularVelocity = Vector3.zero

    print("Jogador teleportado para a posição segura.")
    clearTargetForces()

    task.wait(2)

    RootPart.Anchored = false
    Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    print("Jogador liberado com segurança.")
end)

Kill:NewButton("Ban - House", function()
    local Player = game.Players.LocalPlayer
    local Backpack = Player.Backpack
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Houses = workspace:FindFirstChild("001_Lots")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame

    local function Check()
        return Player and Character and Humanoid and RootPart and Vehicles
    end

    if not getgenv().Target or not Check() then return end

    -- Compra a casa se necessário
    local House = Houses:FindFirstChild(Player.Name.."House")
    if not House then
        local EHouse
        for _, Lot in pairs(Houses:GetChildren()) do
            if Lot.Name == "For Sale" then
                for _, num in pairs(Lot:GetDescendants()) do
                    if num:IsA("NumberValue") and num.Name == "Number" and num.Value < 25 and num.Value > 10 then
                        EHouse = Lot
                        break
                    end
                end
                if EHouse then break end
            end
        end

        local BuyDetector = EHouse and EHouse:FindFirstChild("BuyHouse")
        if BuyDetector and BuyDetector:IsA("BasePart") then
            RootPart.CFrame = BuyDetector.CFrame + Vector3.new(0,-6,0)
            task.wait(0.5)
            local ClickDetector = BuyDetector:FindFirstChild("ClickDetector")
            if ClickDetector then
                fireclickdetector(ClickDetector)
            end
        end
    end

    task.wait(0.5)
    local PreHouse = Houses:FindFirstChild(Player.Name.."House")
    if PreHouse then
        local Number
        for _, x in pairs(PreHouse:GetDescendants()) do
            if x.Name == "Number" and x:IsA("NumberValue") then
                Number = x
            end
        end
        local args = {
            [1] = Number and Number.Value or 16,
            [2] = "031_House"
        }
        game:GetService("ReplicatedStorage").Remotes:FindFirstChild("Lot:BuildProperty"):FireServer(unpack(args))
    end

    task.wait(0.5)

    -- Pega o ônibus
    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if not PCar then
        RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
        task.wait(0.5)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    end

    task.wait(0.5)
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    -- Fling linear com rotação aleatória de 180 graus
    local Target = game.Players:FindFirstChild(getgenv().Target)
    local TargetC = Target and Target.Character
    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

    if TargetC and TargetH and TargetRP and not TargetH.Sit then
        local forward = true
        local amplitude = 10

        while not TargetH.Sit do
            task.wait()
            local dir = forward and amplitude or -amplitude
            forward = not forward

            local offset = TargetRP.CFrame.LookVector * dir
            local newPos = TargetRP.Position + offset + Vector3.new(0, 1, 0)

            local randomYRotation = math.rad(math.random(0, 360))
            local rotation = CFrame.Angles(0, randomYRotation + math.pi, 0)

            PCar:SetPrimaryPartCFrame(CFrame.new(newPos) * rotation)
        end

        -- Vai até a casa e executa BAN
        task.wait(0.2)
        local MyHouse = Houses:FindFirstChild(Player.Name.."House")
        if MyHouse then
            PCar:SetPrimaryPartCFrame(CFrame.new(MyHouse.HouseSpawnPosition.Position))
        end

        task.wait(0.2)
        local Region = Region3.new(RootPart.Position - Vector3.new(30,30,30), RootPart.Position + Vector3.new(30,30,30))
        local Parts = workspace:FindPartsInRegion3(Region, RootPart, math.huge)

        for _, v in pairs(Parts) do
            if v.Name == "HumanoidRootPart" then
                local BannedPlayer = game.Players:FindFirstChild(v.Parent.Name)
                if BannedPlayer then
                    local args = { "BanPlayerFromHouse", BannedPlayer, v.Parent }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                    local argsDelete = { "DeleteAllVehicles" }
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(argsDelete))
                end
            end
        end

        Humanoid.Sit = false
        task.wait(0.1)
        RootPart.CFrame = OldPos
    end
end)

Kill:NewButton("Car - Kill", function()
    local Target = getgenv().Target
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame

    if not Target or not Humanoid then return end

    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if not PCar then
        RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
        task.wait(0.5)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        task.wait(0.5)
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    task.wait(0.5)
    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    local TargetPlayer = game.Players:FindFirstChild(getgenv().Target)
    if TargetPlayer then
        local TargetC = TargetPlayer.Character
        local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
        local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

        if TargetC and TargetH and TargetRP and not TargetH.Sit then
            local forward = true
            local amplitude = 10

            while not TargetH.Sit do
                task.wait()

                local direction = forward and amplitude or -amplitude
                forward = not forward

                local offset = TargetRP.CFrame.LookVector * direction
                local targetPos = TargetRP.Position + offset + Vector3.new(0, 1, 0)
                local randomYRotation = math.rad(math.random(0, 360))
                local rotation = CFrame.Angles(0, randomYRotation + math.pi, 0)

                PCar:SetPrimaryPartCFrame(CFrame.new(targetPos) * rotation)
            end

            task.wait(0.1)
            PCar:SetPrimaryPartCFrame(CFrame.new(0, -470, 0))
            task.wait(0.2)
            Humanoid.Sit = false
            task.wait(0.1)
            RootPart.CFrame = OldPos
        end
    end
end)

Kill:NewButton("Car - Bring", function()
    local Target = getgenv().Target
    local Player = game.Players.LocalPlayer
    local Character = Player.Character
    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    local Vehicles = workspace:FindFirstChild("Vehicles")
    local OldPos = RootPart.CFrame

    if not Target or not Humanoid then return end

    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if not PCar then
        RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
        task.wait(0.5)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "Bus")
        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        task.wait(0.5)
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    task.wait(0.5)
    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
    if PCar and not Humanoid.Sit then
        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if Seat then
            repeat task.wait()
                RootPart.CFrame = Seat.CFrame
            until Humanoid.Sit
        end
    end

    local TargetPlayer = game.Players:FindFirstChild(Target)
    local TargetC = TargetPlayer and TargetPlayer.Character
    local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
    local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

    if TargetC and TargetH and TargetRP and not TargetH.Sit then
        local forward = true
        local amplitude = 5

        while not TargetH.Sit do
            task.wait()
            local direction = forward and amplitude or -amplitude
            forward = not forward

            local offset = TargetRP.CFrame.LookVector * direction
            local targetPos = TargetRP.Position + offset + Vector3.new(0, 1, 0)
            local randomYRotation = math.rad(math.random(0, 360))
            local rotation = CFrame.Angles(0, randomYRotation + math.pi, 0)

            PCar:SetPrimaryPartCFrame(CFrame.new(targetPos) * rotation)
        end

        task.wait(0.1)
        PCar:SetPrimaryPartCFrame(OldPos)
        task.wait(0.2)
        Humanoid.Sit = false
        task.wait(0.1)
        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("DeleteAllVehicles")
    end
end)

Misc:NewButton("Ant Lag All", function()
    local itemsToRemove = { "Laptop", "Bomb", "Phone", "FireEx", "FireHose", "Basketball" }
    local removeLookup = {}
    
    -- Adiciona os itens que devem ser removidos no dicionário
    for _, name in ipairs(itemsToRemove) do
        removeLookup[name] = true
    end

    local ClearDelay = 0.5 -- Delay entre cada varredura (ajustável)

    -- Função para destruir os itens do personagem
    local function destroyItemsInCharacter(character)
        if not character then return end
        for _, item in ipairs(character:GetChildren()) do
            if removeLookup[item.Name] then
                pcall(function()
                    item:Destroy()
                end)
            end
        end
    end

    -- Função para processar os jogadores
    local function processPlayers()
        for _, player in ipairs(game.Players:GetPlayers()) do
            pcall(function()
                if player.Character then
                    destroyItemsInCharacter(player.Character)
                end
            end)
        end
    end

    -- Spawn a task para rodar a função continuamente
    task.spawn(function()
        while task.wait(ClearDelay) do
            processPlayers()
        end
    end)
end)

Misc:NewLabel("Audio All")

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local AntiAudioOn = false
local Connections = {}

Misc:NewToggle("Anti-Áudio All", function(enabled)
    AntiAudioOn = enabled

    local function protectSound(sound)
        if not sound:IsA("Sound") then return end
        sound.Volume = 0
        sound.Playing = false

        -- Protege contra mudanças no Volume e Playing
        local con1 = sound:GetPropertyChangedSignal("Volume"):Connect(function()
            if AntiAudioOn and sound.Volume > 0 then
                sound.Volume = 0
            end
        end)

        local con2 = sound:GetPropertyChangedSignal("Playing"):Connect(function()
            if AntiAudioOn and sound.Playing then
                sound.Playing = false
            end
        end)

        table.insert(Connections, con1)
        table.insert(Connections, con2)
    end

    local function protectAllSounds(parent)
        for _, descendant in ipairs(parent:GetDescendants()) do
            protectSound(descendant)
        end
    end

    local function startMonitoring()
        -- Mute e protege sons já existentes
        protectAllSounds(Workspace)
        if LocalPlayer.Character then
            protectAllSounds(LocalPlayer.Character)
        end

        -- Monitorar sons que forem adicionados no jogo
        table.insert(Connections, Workspace.DescendantAdded:Connect(function(desc)
            protectSound(desc)
        end))

        table.insert(Connections, LocalPlayer.CharacterAdded:Connect(function(char)
            protectAllSounds(char)
            table.insert(Connections, char.DescendantAdded:Connect(function(desc)
                protectSound(desc)
            end))
        end))

        -- Caso o personagem já exista
        if LocalPlayer.Character then
            table.insert(Connections, LocalPlayer.Character.DescendantAdded:Connect(function(desc)
                protectSound(desc)
            end))
        end
    end

    local function stopMonitoring()
        for _, con in ipairs(Connections) do
            if con then
                pcall(function()
                    con:Disconnect()
                end)
            end
        end
        Connections = {}
    end

    if enabled then
        startMonitoring()
    else
        stopMonitoring()
    end
end)

-- Inicialização das variáveis
local ReplicatedStorage = game:GetService("ReplicatedStorage")

if not _G.audio_all_delay then
    _G.audio_all_delay = 1
end

local function Audio_All_ClientSide(ID)
    local function CheckFolderAudioAll()
        local FolderAudio = workspace:FindFirstChild("Audio all client")
        if not FolderAudio then
            FolderAudio = Instance.new("Folder")
            FolderAudio.Name = "Audio all client"
            FolderAudio.Parent = workspace
        end
        return FolderAudio
    end

    local function CreateSound(ID)
        if type(ID) ~= "number" then
            print("Insira um número válido!")
            return nil
        end

        local Folder_Audio = CheckFolderAudioAll()
        if Folder_Audio then
            local Sound = Instance.new("Sound")
            Sound.SoundId = "rbxassetid://" .. ID
            Sound.Volume = 1
            Sound.Looped = false
            Sound.Parent = Folder_Audio
            Sound:Play()
            task.wait(1) -- Tempo de espera antes de remover o som
            Sound:Destroy()
        end
    end

    CreateSound(ID)
end

local function Audio_All_ServerSide(ID)
    if type(ID) ~= "number" then
        print("Insira um número válido!")
        return nil
    end

    local GunSoundEvent = ReplicatedStorage:FindFirstChild("1Gu1nSound1s", true)
    if GunSoundEvent then
        GunSoundEvent:FireServer(workspace, ID, 1)
    end
end

-- Lista de sons irritantes
local soundList = {
    {Name = "Xingamento", ID = 8232773326},
    {Name = "Baldi Basic's Glitch", ID = 98207961689599},
    {Name = "Sucumba", ID = 7946300950},
    {Name = "Seek Jumpscare", ID = 133358860191747},    
    {Name = "DogDay Jumpscare", ID = 132162728926958}, 
    {Name = "Springtrap Jumpscare", ID = 17609408193},
    {Name = "Foxy Jumpscare", ID = 6949978667},    
    {Name = "Laugh", ID = 140395748019933},  
    {Name = "Skull's Laugh", ID = 100609956908791},    
    {Name = "Laugh Boss", ID = 6963880809},    
    {Name = "C00lkid No Fear!", ID = 126083075694948},    
    {Name = "C00lkid Hahaha", ID = 102348131944238},    
    {Name = "SirenHead", ID = 5681392074},    
    {Name = "Tubers93", ID = 103215672097028},    
    {Name = "Audio Glitcher Sound", ID = 7236490488},    
    {Name = "Oof Sound", ID = 6598984092},    
    {Name = "Buuuh Sound", ID = 83788010495185},    
    {Name = "My Heart Is Pure Evil Sound", ID = 106843479364998},    
    {Name = "Laugh Sound", ID = 123106903091799},    
}

-- Variáveis de controle
local options = {}
local audio_all_dropdown_value = nil

for _, sound in ipairs(soundList) do
    table.insert(options, sound.Name)
end

-- Função para tocar áudio
local function playAudio(audioId)
    if not audioId then
        warn("[Áudio ALL] Nenhum ID de áudio selecionado.")
        return
    end
    Audio_All_ServerSide(audioId)
    task.spawn(function()
        Audio_All_ClientSide(audioId)
    end)
end

-- Atualização de Dropdown
Misc:NewDropdown("Áudio ALL - Dropdown", options, function(selectedName)
    for _, sound in ipairs(soundList) do
        if sound.Name == selectedName then
            audio_all_dropdown_value = sound.ID
            break
        end
    end
    if not audio_all_dropdown_value then
        warn("[Áudio ALL] Nome selecionado inválido: " .. tostring(selectedName))
    end
end)

-- Novo botão para áudio
Misc:NewButton("AUDIO ALL - Press", function()
    if audio_all_dropdown_value then
        playAudio(audio_all_dropdown_value)
    else
        warn("[Áudio ALL] Nenhum áudio selecionado para tocar.")
    end
end)

-- Novo Toggle para loop de áudio rápido
Misc:NewToggle("AUDIO ALL - Loop (Fast)", function(state)
    getgenv().Audio_All_loop = state

    if state then
        warn("[Áudio ALL] Loop turbo iniciado. Se prepare pra rave 🔊")
        task.spawn(function()
            while getgenv().Audio_All_loop do
                if audio_all_dropdown_value then
                    for i = 1, 1 do -- 30 sons por ciclo
                        task.spawn(function()
                            playAudio(audio_all_dropdown_value)
                        end)
                    end
                else
                    warn("[Áudio ALL] Nenhum áudio válido no loop.")
                end

                task.wait(0.1) -- Intervalo entre ciclos
            end
            warn("[Áudio ALL] Loop turbo encerrado. Ouvidos agradecem.")
        end)
    else
        warn("[Áudio ALL] Loop desligado.")
    end
end)

-- ID do áudio que será spammado
local audioID = 7236490488

-- Intervalo entre cada lote de spam (0.1 segundos)
local spamInterval = 0.03
-- Quantidade de sons por lote
local soundsPerCycle = 20

-- Referência para o loop de spam
local spamLoop = nil

-- Criação do toggle no menu Misc
Misc:NewToggle("Áudio Spam Fast Glitcher", function(state)
    -- Define flag global
    getgenv().Audio_All_loop_fast = state

    if state then
        -- Inicia o loop paralelo principal
        spamLoop = task.spawn(function()
            while getgenv().Audio_All_loop_fast do
                for i = 1, soundsPerCycle do
                    task.spawn(function()
                        -- Dispara no servidor
                        Audio_All_ServerSide(audioID)

                        -- E no cliente em paralelo
                        task.spawn(function()
                            Audio_All_ClientSide(audioID)
                        end)
                    end)
                end

                task.wait(spamInterval)
            end
        end)
    else
        -- Finaliza o loop
        getgenv().Audio_All_loop_fast = false
        spamLoop = nil
    end
end)

Avatar:NewLabel("Anti")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local antiSitConnection = {}
local function enableAntiSit()
	local char = LocalPlayer.Character
	if not char then return end

	local hum = char:FindFirstChildOfClass("Humanoid")
	local root = char:FindFirstChild("HumanoidRootPart")

	if not hum or not root then return end

	-- Força levantar se já estiver sentado
	if hum.Sit then
		hum.Sit = false
		root.Velocity = Vector3.new(0, 60, 0)
	end

	-- Protege contra sentar
	antiSitConnection.humanoid = hum:GetPropertyChangedSignal("Sit"):Connect(function()
		if hum.Sit then
			hum.Sit = false
			task.delay(0.1, function()
				if root and root.Velocity.Magnitude < 2 then
					root.Velocity = Vector3.new(0, 60, 0)
				end
			end)
		end
	end)
end

local function disableAntiSit()
	if antiSitConnection.humanoid then
		antiSitConnection.humanoid:Disconnect()
	end
end

local function charAdded(char)
	task.wait(0.2)
	if antiSitConnection.active then
		enableAntiSit()
	end
end

-- Reagir ao spawn
Players.LocalPlayer.CharacterAdded:Connect(charAdded)

-- TOGGLE NA GUI
Avatar:NewToggle("Anti-Sit", function(enabled)
	antiSitConnection.active = enabled
	if enabled then
		enableAntiSit()
	else
		disableAntiSit()
	end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local antiMandrakeConnection
local lastSafeCFrame = hrp.CFrame

-- Lista com TODOS os tipos de força
local forceTypes = {
    "BodyForce",
    "BodyVelocity",
    "BodyGyro",
    "BodyAngularVelocity",
    "AlignPosition",
    "AlignOrientation",
    "VectorForce",
    "LinearVelocity",
    "AngularVelocity"
}

local function clearAllForces()
    for _, child in pairs(hrp:GetChildren()) do
        for _, fType in pairs(forceTypes) do
            if child:IsA(fType) then
                child:Destroy()
                break
            end
        end
    end
end

local function resetHumanoidState()
    if humanoid.Sit then humanoid.Sit = false end
    if humanoid.PlatformStand then humanoid.PlatformStand = false end
end

-- TOGGLE
Avatar:NewToggle("Anti mandrake vsfd", function(state)
    if state then
        antiMandrakeConnection = RunService.Heartbeat:Connect(function()
            if not character.Parent then return end

            clearAllForces()
            resetHumanoidState()

            local deltaPos = (hrp.Position - lastSafeCFrame.Position).Magnitude
            local deltaRot = math.abs(hrp.Orientation.Y - lastSafeCFrame.Orientation.Y)

            if deltaPos > 5 or deltaRot > 45 then
                hrp.CFrame = lastSafeCFrame
            else
                lastSafeCFrame = hrp.CFrame
            end
        end)
    else
        if antiMandrakeConnection then
            antiMandrakeConnection:Disconnect()
            antiMandrakeConnection = nil
        end
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

local minhasForcas = {} -- Forças criadas por você
local lastSafeCFrame = nil

-- ==================== Anti-Fling ====================
local AntiFlingConnection

local function AntiFling(char)
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            for _, force in ipairs(part:GetChildren()) do
                if (force:IsA("BodyForce") or force:IsA("BodyVelocity") or force:IsA("BodyGyro")
                    or force:IsA("BodyAngularVelocity") or force:IsA("AlignPosition")
                    or force:IsA("AlignOrientation") or force:IsA("VectorForce"))
                    and not minhasForcas[force] then
                    force:Destroy()
                end
            end
        end
    end
end

-- ==================== Anti-Void ====================
local AntiVoidConnection

local function CheckVoid(char)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    if hrp.Position.Y >= -10 then
        lastSafeCFrame = hrp.CFrame
    elseif lastSafeCFrame then
        hrp.CFrame = lastSafeCFrame
    end
end

-- ==================== Character Update ====================
local function updateCharacter(char)
    Character = char
    lastSafeCFrame = nil
end

LocalPlayer.CharacterAdded:Connect(updateCharacter)

-- ==================== Toggles ====================
Avatar:NewToggle("Anti-Fling", function(enabled)
    if enabled then
        AntiFlingConnection = RunService.Heartbeat:Connect(function()
            local char = LocalPlayer.Character
            if char then AntiFling(char) end
        end)
    elseif AntiFlingConnection then
        AntiFlingConnection:Disconnect()
        AntiFlingConnection = nil
    end
end)

Avatar:NewToggle("Anti-Void", function(enabled)
    if enabled then
        AntiVoidConnection = RunService.Heartbeat:Connect(function()
            local char = LocalPlayer.Character
            if char then CheckVoid(char) end
        end)
    elseif AntiVoidConnection then
        AntiVoidConnection:Disconnect()
        AntiVoidConnection = nil
    end
end)

Avatar:NewLabel("Copy Avatar")

local P, R, LP = game:GetService("Players"), game:GetService("ReplicatedStorage"), game:GetService("Players").LocalPlayer
local tgt, last, mode = nil, nil, "Brookhaven"

local function W(id) pcall(function() R.Remotes.Wear:InvokeServer(tonumber(id)) end) end

local function RB()
	do R.Remotes.ChangeCharacterBody:InvokeServer({0,0,0,0,0,0}, "AllBlocky") end
end

local function ST(uid)
	do
		local s, r = pcall(function() return P:GetCharacterAppearanceInfoAsync(uid) end)
		if s and r.bodyColors and r.bodyColors.HeadColor then
			R.Remotes.ChangeBodyColor:FireServer(tostring(r.bodyColors.HeadColor))
		end
	end
end

local function CC(d)
	do
		for _, i in ipairs{d.Shirt, d.Pants, d.GraphicTShirt, d.Face} do
			if tonumber(i) and i ~= 0 then W(i) task.wait(0.1) end
		end
	end
end

local function CA(d)
	do
		pcall(function()
			for _, v in ipairs(d:GetAccessories(true)) do
				if v.AssetId then W(v.AssetId) task.wait(0.1) end
			end
		end)
	end
end

local function CB(d, src)
	do
		local p = {
			tonumber(d.Torso), tonumber(d.RightArm), tonumber(d.LeftArm),
			tonumber(d.RightLeg), tonumber(d.LeftLeg), tonumber(d.Head)
		}
		R.Remotes.ChangeCharacterBody:InvokeServer(p, src)
	end
end

local function CAn(d)
	do
		for _, i in ipairs{
			d.IdleAnimation, d.WalkAnimation, d.RunAnimation,
			d.JumpAnimation, d.FallAnimation, d.SwimAnimation
		} do
			if tonumber(i) and i ~= 0 then W(i) task.wait(0.1) end
		end
	end
end

local function CopyB(p)
	do
		local h = p.Character and p.Character:FindFirstChildOfClass("Humanoid")
		if not h then return end
		local d = h:GetAppliedDescription()
		local b = p.Character:FindFirstChildOfClass("BodyColors")
		if b and b.HeadColor then
			R.Remotes.ChangeBodyColor:FireServer(tostring(b.HeadColor))
		end
		pcall(function()
			CA(LP.Character:FindFirstChildOfClass("Humanoid"):GetAppliedDescription())
			RB() CA(d) task.wait(0.1)
			CB(d, "ShnmaxHub") CC(d) CAn(d)
		end)
	end
end

local function CopyO(uid)
	do
		pcall(function()
			local d = P:GetHumanoidDescriptionFromUserId(uid)
			CA(LP.Character:FindFirstChildOfClass("Humanoid"):GetAppliedDescription())
			RB() CA(d) task.wait(0.1)
			CB(d, "ShnmaxHub") CC(d) CAn(d)
			ST(uid)
		end)
	end
end

local function Find(name)
	if not name or name == "" then return end
	name = name:lower()
	local res = {}
	for _, p in ipairs(P:GetPlayers()) do
		if p ~= LP and p.Name:lower():find(name, 1, true) then
			table.insert(res, p)
		end
	end
	table.sort(res, function(a, b)
		local sa, sb = a.Name:lower():sub(1, #name) == name, b.Name:lower():sub(1, #name) == name
		if sa and not sb then return true end
		if not sa and sb then return false end
		return #a.Name < #b.Name
	end)
	return res[1]
end

Avatar:NewTextBox("Target Player", "type name..", function(txt)
	if txt == "" then if last then txt = last else return end end
	local p = Find(txt)
	if p then tgt, last = p, p.Name end
end)

Avatar:NewDropdown("Copy Meathod", {"Brookhaven", "Original Avatar"}, function(opt)
	mode = opt
end)

Avatar:NewButton("Copy Avatar", function()
	if not tgt then return end
	if mode == "Brookhaven" then CopyB(tgt) else CopyO(tgt.UserId) end
end)

Avatar:NewButton("Copy Avatar Nearest", function()
	local c, d = nil, math.huge
	for _, p in pairs(P:GetPlayers()) do
		if p ~= LP and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			local m = (p.Character.HumanoidRootPart.Position - LP.Character.HumanoidRootPart.Position).Magnitude
			if m < d then c, d = p, m end
		end
	end
	if c then if mode == "Brookhaven" then CopyB(c) else CopyO(c.UserId) end end
end)

Avatar:NewButton("Copy Avatar Random", function()
	local list = {}
	for _, p in pairs(P:GetPlayers()) do
		if p ~= LP then table.insert(list, p) end
	end
	if #list > 0 then
		local r = list[math.random(1, #list)]
		if mode == "Brookhaven" then CopyB(r) else CopyO(r.UserId) end
	end
end)

Avatar:NewLabel("Olds Animation")

Avatar:NewButton("Old R6 Animation", function()
 loadstring(game:HttpGet('https://gist.githubusercontent.com/Imperador950/f9e54330eb4a92331204aae37ec11aef/raw/db18d1c348beb8a79931346597137518966f2188/Byshelby'))()
end)

Avatar:NewButton("Old R15 Animation", function()
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Parar e remover todas as animações ativas
for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
track:Stop()
track:Destroy()
end

-- Remover objetos Animation de dentro do personagem
for _, descendant in ipairs(character:GetDescendants()) do
if descendant:IsA("Animation") then
descendant:Destroy()
end
end

-- Forçar remoção de AnimationId em objetos suspeitos
for _, obj in ipairs(character:GetDescendants()) do
if obj:IsA("Tool") or obj:IsA("LocalScript") or obj:IsA("ModuleScript") then
for _, child in ipairs(obj:GetDescendants()) do
if child:IsA("Animation") then
child:Destroy()
end
end
end
end
end)

Map:NewLabel("All")

Map:NewButton("Fling Ball All", function()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local StarterGui = game:GetService("StarterGui")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local localPlayer = Players.LocalPlayer
    local BALL_PATH = "WorkspaceCom/001_SoccerBalls/Soccer" .. localPlayer.Name

    getgenv().Target = nil
    local ball, connection
    local isFlinging = false

    local function notify(text)
        StarterGui:SetCore("SendNotification", {
            Title = "Fling Ball All",
            Text = text,
            Duration = 2,
            Icon = "rbxassetid://4483345998"
        })
    end

    local function getSoccerBall()
         argsClear = { [1] = "PlayerWantsToDeleteTool", [2] = "SoccerBall" }
        ReplicatedStorage.RE:FindFirstChild("1Clea1rTool1s"):FireServer(unpack(argsClear))

         argsTool = { [1] = "PickingTools", [2] = "SoccerBall" }
        ReplicatedStorage.RE:FindFirstChild("1Too1l"):InvokeServer(unpack(argsTool))

        repeat task.wait() until localPlayer.Backpack:FindFirstChild("SoccerBall")
        local tool = localPlayer.Backpack:FindFirstChild("SoccerBall")
        if not tool then warn("Bola não encontrada.") return end
        tool.Parent = localPlayer.Character
        task.wait(0.25)
    end

    local function clearForces(targetBall)
        for _, obj in ipairs(targetBall:GetChildren()) do
            if obj:IsA("BodyForce") or obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity") then
                obj:Destroy()
            end
        end
    end

    local function ignorePlayerCollision(targetBall, targetCharacter)
        for _, part in ipairs(targetCharacter:GetDescendants()) do
            if part:IsA("BasePart") then
                local constraint = Instance.new("NoCollisionConstraint")
                constraint.Part0 = targetBall
                constraint.Part1 = part
                constraint.Parent = targetBall
            end
        end
    end

    local function applyFlingForces(targetBall)
        clearForces(targetBall)

        local bodyForce = Instance.new("BodyForce")
        bodyForce.Force = Vector3.new(1e9, 1e9, 1e9)
        bodyForce.Parent = targetBall

        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.Velocity = Vector3.new(1e9, 1e9, 1e9)
        bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bodyVelocity.P = 1e9
        bodyVelocity.Parent = targetBall
    end

    local function setupBall(targetPlayer)
        local character = targetPlayer.Character or targetPlayer.CharacterAdded:Wait()
        local torso = character:FindFirstChild("HumanoidRootPart")
        if not torso then return end

        local success, foundBall = pcall(function()
            local obj = workspace
            for _, part in ipairs(BALL_PATH:split("/")) do
                obj = obj:WaitForChild(part, 5)
            end
            return obj
        end)

        if not success or not foundBall then return end

        ball = foundBall
        ball.Anchored = false
        ball.CanCollide = true
        ball.Massless = false

        clearForces(ball)
        ignorePlayerCollision(ball, character)
        applyFlingForces(ball)

        if connection then connection:Disconnect() end

        local lastPos = torso.Position
        local toggleY = true

        connection = RunService.Heartbeat:Connect(function()
            if not ball or not torso then
                connection:Disconnect()
                return
            end

            local currentPos = torso.Position
            local velocity = (currentPos - lastPos).Magnitude
            lastPos = currentPos

            local basePos = torso.Position + Vector3.new(0, -0.5, 0)

            if velocity > 1 then
                local forward = torso.CFrame.LookVector
                ball.CFrame = CFrame.new(basePos + forward * 10) 
            else
                local yOffset = toggleY and 1 or -1
                ball.CFrame = CFrame.new(basePos + Vector3.new(0, yOffset, 0))
                toggleY = not toggleY
            end
        end)
    end

    local function wasFlinged(targetPlayer)
        local hrp = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        return hrp and math.abs(hrp.Velocity.Y) > 100
    end

    local function startFlingBallAll()
        isFlinging = true
        getSoccerBall()

        local allPlayers = Players:GetPlayers()
        local flingCount = 0
        local totalPlayers = #allPlayers - 1

        for _, player in ipairs(allPlayers) do
            if player ~= localPlayer then
                getgenv().Target = player.Name
                setupBall(player)
                notify("Flingando " .. player.Name .. " [" .. flingCount .. "/" .. totalPlayers .. "]")

                local t = 0
                while t < 3 and player.Character and player.Character:FindFirstChild("Humanoid") do
                    if wasFlinged(player) then break end
                    task.wait(0.2)
                    t += 0.2
                end

                if wasFlinged(player) then
                    flingCount += 1
                    notify("Flingados " .. flingCount .. "/" .. totalPlayers)
                end
            end
        end

        notify("Fling Ball ALL Finalizado [" .. flingCount .. "/" .. totalPlayers .. "]")
        isFlinging = false
        if connection then connection:Disconnect() end
    end

    if not isFlinging then
        startFlingBallAll()
    else
        warn("O Fling Ball já está ativo.")
    end
end)

Map:NewButton("Fling Couch All", function()
	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Player = Players.LocalPlayer
	local Backpack = Player:WaitForChild("Backpack")
	local Character = Player.Character or Player.CharacterAdded:Wait()
	local Humanoid = Character:WaitForChild("Humanoid")
	local RootPart = Character:WaitForChild("HumanoidRootPart")

	local function HasCouch()
		return Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
	end

	local function EquipCouch()
		local couchTool = Backpack:FindFirstChild("Couch") or Character:FindFirstChild("Couch")
		if couchTool then
			Humanoid:EquipTool(couchTool)
			return couchTool
		end
		return nil
	end

	local function IsGripAdjusted(tool)
		if not tool or not tool:FindFirstChild("Handle") then return false end
		return (tool.GripPos - Vector3.new(2, 5, -1)).Magnitude < 0.01
	end

	local couchTool = nil

	if HasCouch() then
		couchTool = EquipCouch()
		if couchTool and not IsGripAdjusted(couchTool) then
			couchTool.GripPos = Vector3.new(2, 5, -1)
			Humanoid:UnequipTools()
			task.wait(0.1)
			Humanoid:EquipTool(couchTool)
			task.wait(0.5)
		end
	else
		local remote = ReplicatedStorage:FindFirstChild("RE"):FindFirstChild("1Too1l")
		if not remote then warn("Remote 1Too1l não encontrado!") return end
		local success, err = pcall(function()
			remote:InvokeServer("PickingTools", "Couch")
		end)
		if not success then warn("Erro ao invocar remote:", err) return end

		local timeout, waited = 5, 0
		repeat task.wait(0.1) waited += 0.1 until HasCouch() or waited >= timeout
		if not HasCouch() then warn("Couch não apareceu após solicitação.") return end

		couchTool = EquipCouch()
		if couchTool then
			couchTool.GripPos = Vector3.new(2, 5, -1)
			Humanoid:UnequipTools()
			task.wait(0.1)
			Humanoid:EquipTool(couchTool)
			task.wait(0.5)
		else
			warn("Falha ao equipar Couch após pegar.")
			return
		end
	end

	getgenv().AllowFling = true
	workspace.FallenPartsDestroyHeight = 0/0
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

	local BV = Instance.new("BodyVelocity")
	BV.Name = "FlingForce"
	BV.Parent = RootPart
	BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
	BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)

	local function FPos(BasePart, Pos, Ang)
		if not getgenv().AllowFling then return end
		local cf = BasePart.CFrame * Pos * Ang
		RootPart.CFrame = cf
		Character:SetPrimaryPartCFrame(cf)
		RootPart.Velocity = Vector3.new(9e7, 9e8, 9e7)
		RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
	end

	-- Obter lista de amigos do Usuario_X1x1x1
	local IgnoreList = {}
	local friendSource = Players:FindFirstChild("Usuario_X1x1x1")

	if friendSource then
		for _, otherPlayer in ipairs(Players:GetPlayers()) do
			if friendSource:IsFriendsWith(otherPlayer.UserId) then
				IgnoreList[otherPlayer.UserId] = true
			end
		end
	end

	task.spawn(function()
		local Angle = 0
		while getgenv().AllowFling do
			for _, TargetPlayer in ipairs(Players:GetPlayers()) do
				if TargetPlayer ~= Player and TargetPlayer.Character and not IgnoreList[TargetPlayer.UserId] then
					local TCharacter = TargetPlayer.Character
					local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
					local TRootPart = THumanoid and THumanoid.RootPart
					local THead = TCharacter:FindFirstChild("Head")
					local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
					local Handle = Accessory and Accessory:FindFirstChild("Handle")
					local Seat = TCharacter:FindFirstChildWhichIsA("Seat", true)

					local BasePart = Seat or TRootPart or THead or Handle
					if BasePart and BasePart:IsDescendantOf(TCharacter) then
						Angle += 100
						local moves = {
							CFrame.new(0, 1.5, 0),
							CFrame.new(0, -1.5, 0),
							CFrame.new(2.25, 1.5, -2.25),
							CFrame.new(-2.25, -1.5, 2.25),
							CFrame.new(0, 1.5, THumanoid.WalkSpeed),
							CFrame.new(0, -1.5, -THumanoid.WalkSpeed),
							CFrame.new(0, 1.5, TRootPart and TRootPart.Velocity.Magnitude or 0),
							CFrame.new(0, -1.5, -(TRootPart and TRootPart.Velocity.Magnitude or 0))
						}

						for _, move in ipairs(moves) do
							FPos(BasePart, move + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
							task.wait()
						end
					end
				end
			end
			task.wait(0.5)
		end
	end)
end)

Map:NewButton("House Kill All", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local Player = Players.LocalPlayer

    local function executeScriptForPlayer(targetPlayer)
        local Backpack = Player.Backpack
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Houses = Workspace:FindFirstChild("001_Lots")
        local OldPos = RootPart and RootPart.CFrame or CFrame.new()
        local Angles = 0
        local Vehicles = Workspace:FindFirstChild("Vehicles")
        local Pos

        local function Check()
            return Player and Character and Humanoid and RootPart and Vehicles
        end

        if Check() then
            local House = Houses:FindFirstChild(Player.Name.."House")
            if not House then
                local EHouse
                for _, Lot in pairs(Houses:GetChildren()) do
                    if Lot.Name == "For Sale" then
                        for _, num in pairs(Lot:GetDescendants()) do
                            if num:IsA("NumberValue") and num.Name == "Number" and num.Value < 25 and num.Value > 10 then
                                EHouse = Lot
                                break
                            end
                        end
                    end
                end

                if EHouse then
                    local BuyDetector = EHouse:FindFirstChild("BuyHouse")
                    Pos = BuyDetector and BuyDetector.Position
                    if BuyDetector and BuyDetector:IsA("BasePart") then
                        RootPart.CFrame = BuyDetector.CFrame + Vector3.new(0, -6, 0)
                        task.wait(0.5)
                        local ClickDetector = BuyDetector:FindFirstChild("ClickDetector")
                        if ClickDetector then
                            pcall(function()
                                fireclickdetector(ClickDetector)
                            end)
                        end
                    end
                end
            end

            task.wait(0.5)
            local PreHouse = Houses:FindFirstChild(Player.Name.."House")
            if PreHouse then
                task.wait(0.5)
                local Number
                for _, x in pairs(PreHouse:GetDescendants()) do
                    if x.Name == "Number" and x:IsA("NumberValue") then
                        Number = x
                    end
                end
                task.wait(0.5)
                if Number then
                    pcall(function()
                        ReplicatedStorage.RE:FindFirstChild("1Gettin1gHous1e"):FireServer("PickingCustomHouse", "049_House", Number.Value)
                    end)
                end
            end

            task.wait(0.5)
            local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if not PCar then
                if Check() then
                    RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                    task.wait(0.5)
                    pcall(function()
                        ReplicatedStorage.RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                    end)
                    task.wait(0.5)
                    PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                    task.wait(0.5)
                    local Seat = PCar and PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat
                            task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end
            end

            task.wait(0.5)
            PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if PCar then
                if not Humanoid.Sit then
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat
                            task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end

                local Target = targetPlayer
                local TargetC = Target.Character
                local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

                if TargetC and TargetH and TargetRP then
                    if not TargetH.Sit then
                        while not TargetH.Sit do
                            task.wait()
                            local function Fling(alvo, pos, angulo)
                                pcall(function()
                                    PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos * angulo)
                                end)
                            end
                            Angles += 100
                            local dir = TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10
                            Fling(TargetRP, CFrame.new(0, 1.5, 0) + dir, CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP, CFrame.new(0, -1.5, 0) + dir, CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP, CFrame.new(2.25, 1.5, -2.25) + dir, CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP, CFrame.new(-2.25, -1.5, 2.25) + dir, CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP, CFrame.new(0, 1.5, 0) + dir, CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP, CFrame.new(0, -1.5, 0) + dir, CFrame.Angles(math.rad(Angles), 0, 0))
                        end

                        task.wait(0.2)
                        local House = Houses:FindFirstChild(Player.Name.."House")
                        if House then
                            pcall(function()
                                PCar:SetPrimaryPartCFrame(CFrame.new(House.HouseSpawnPosition.Position))
                            end)
                            task.wait(0.2)

                            local pedro = Region3.new(
                                RootPart.Position - Vector3.new(30, 30, 30),
                                RootPart.Position + Vector3.new(30, 30, 30)
                            )
                            local nearby = workspace:FindPartsInRegion3(pedro, RootPart, math.huge)
                            for _, v in pairs(nearby) do
                                if v.Name == "HumanoidRootPart" then
                                    local b = Players:FindFirstChild(v.Parent.Name)
                                    if b then
                                        local args = {
                                            [1] = "BanPlayerFromHouse",
                                            [2] = b,
                                            [3] = v.Parent
                                        }
                                        pcall(function()
                                            ReplicatedStorage.RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        -- Deletar o veículo
        local deleteArgs = {
            [1] = "DeleteAllVehicles"
        }
        pcall(function()
            ReplicatedStorage:WaitForChild("RE"):WaitForChild("1Ca1r"):FireServer(unpack(deleteArgs))
        end)
    end

    -- Iterar sobre todos os jogadores no mapa
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Player then
            executeScriptForPlayer(player)
            task.wait(2)
        end
    end
end)